<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>JPEG压缩/解压缩用于无线通信 | JrunDing</title><meta name="author" content="JrunDing"><meta name="copyright" content="JrunDing"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="最近有无线传输图像的需求，因为原图数据量很大，因此需要使用JPEG或其他压缩算法对原图进行压缩后再传输  图像文件和压缩标准​	常见的图像文件后缀有.arw  .bmp   .jpg   .png   .gif   .tif   .svg等 ​	.arw：arw是索尼相机的RAW图像格式。RAW格式可以称为是原始图片数据格式，可以进行更多的后期调整，图像文件中包括光圈、快门、ISO、GPS等相机">
<meta property="og:type" content="article">
<meta property="og:title" content="JPEG压缩&#x2F;解压缩用于无线通信">
<meta property="og:url" content="http://jrunding.github.io/2023/07/20/JPEG%E5%8E%8B%E7%BC%A9-%E8%A7%A3%E5%8E%8B%E7%BC%A9%E7%94%A8%E4%BA%8E%E6%97%A0%E7%BA%BF%E9%80%9A%E4%BF%A1/index.html">
<meta property="og:site_name" content="JrunDing">
<meta property="og:description" content="最近有无线传输图像的需求，因为原图数据量很大，因此需要使用JPEG或其他压缩算法对原图进行压缩后再传输  图像文件和压缩标准​	常见的图像文件后缀有.arw  .bmp   .jpg   .png   .gif   .tif   .svg等 ​	.arw：arw是索尼相机的RAW图像格式。RAW格式可以称为是原始图片数据格式，可以进行更多的后期调整，图像文件中包括光圈、快门、ISO、GPS等相机">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s1.ax1x.com/2023/03/03/ppkg98x.jpg">
<meta property="article:published_time" content="2023-07-20T14:19:30.000Z">
<meta property="article:modified_time" content="2023-07-20T15:33:41.699Z">
<meta property="article:author" content="JrunDing">
<meta property="article:tag" content="Communication, Automation, ML, DL, NLP, CV, Movie, photography">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s1.ax1x.com/2023/03/03/ppkg98x.jpg"><link rel="shortcut icon" href="https://z1.ax1x.com/2023/11/13/piJMDnH.jpg"><link rel="canonical" href="http://jrunding.github.io/2023/07/20/JPEG%E5%8E%8B%E7%BC%A9-%E8%A7%A3%E5%8E%8B%E7%BC%A9%E7%94%A8%E4%BA%8E%E6%97%A0%E7%BA%BF%E9%80%9A%E4%BF%A1/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: JrunDing","link":"链接: ","source":"来源: JrunDing","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JPEG压缩/解压缩用于无线通信',
  isPost: true,
  isHome: false,
  isHighlightShrink: undefined,
  isToc: true,
  postUpdate: '2023-07-20 23:33:41'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js/themes/blue/pace-theme-minimal.min.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://z1.ax1x.com/2023/11/13/piJMDnH.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">207</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/talk/"><span> Talk</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><span> Music</span></a></div><div class="menus_item"><a class="site-page" href="/movie/"><span> Movie</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s1.ax1x.com/2023/03/03/ppkg98x.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="JrunDing"></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/talk/"><span> Talk</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><span> Music</span></a></div><div class="menus_item"><a class="site-page" href="/movie/"><span> Movie</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JPEG压缩/解压缩用于无线通信</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-07-20T14:19:30.000Z" title="发表于 2023-07-20 22:19:30">2023-07-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-07-20T15:33:41.699Z" title="更新于 2023-07-20 23:33:41">2023-07-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Communication/">Communication</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>30分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JPEG压缩/解压缩用于无线通信"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><span class="disqus-comment-count"><a href="http://jrunding.github.io/2023/07/20/JPEG%E5%8E%8B%E7%BC%A9-%E8%A7%A3%E5%8E%8B%E7%BC%A9%E7%94%A8%E4%BA%8E%E6%97%A0%E7%BA%BF%E9%80%9A%E4%BF%A1/#disqus_thread"><i class="fa-solid fa-spinner fa-spin"></i></a></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>最近有无线传输图像的需求，因为原图数据量很大，因此需要使用JPEG或其他压缩算法对原图进行压缩后再传输</p>
</blockquote>
<h1 id="图像文件和压缩标准"><a href="#图像文件和压缩标准" class="headerlink" title="图像文件和压缩标准"></a>图像文件和压缩标准</h1><p>​	常见的图像文件后缀有<code>.arw  .bmp   .jpg   .png   .gif   .tif   .svg</code>等</p>
<p>​	<code>.arw</code>：arw是索尼相机的RAW图像格式。RAW格式可以称为是原始图片数据格式，可以进行更多的后期调整，图像文件中包括光圈、快门、ISO、GPS等相机信息。RAW是广大摄影爱好者的常用格式</p>
<p>​	<code>.bmp</code>：BMP格式是微软公司制定的图形标准，最大的优点就是在PC上兼容度一流，几乎能被所有的图形软件“接受”，可称为通用格式，就算不装任何看图软件，用Windows的“画笔”一样可以看。其结构简单，未经过压缩，储存为bmp格式的图形不会失真，但文件比较大，而且不支持Alpha（透明背景）通道</p>
<p>​	<code>.jpg</code>：JPG格式是目前网络上最流行的图形格式，它可以把文件容量压缩到最小的格式。JPG支持不同程度的压缩比，您可以视情况调整压缩倍率，压缩比越大，品质就越低；相反地，压缩比越小，品质就越好。不过要注意的一点是，这种压缩法属于有损压缩，文件的压缩会使得图形品质下降。JPEG（Joint Photographic Experts Group，联合图形专家组）是由CCITT（国际电报电话咨询委员会）和ISO（国际标准化组织）联合组成的一个图像专家组</p>
<p>​	<code>.png</code>：PNG（Portable Network Graphics，可移植的网络图形格式）是一种新兴的网络图形格式，结合了GIF和JPEG的优点，具有存储形式丰富的特点。PNG最大色深为48bit，采用<strong>无损压缩</strong>方案存储，是一种位图文件。著名的Macromedia公司的Fireworks的默认格式就是PNG。比起JPG等其他格式多了Alpha通道</p>
<p>​	<code>.gif</code>：CompuServe公司在1987年开发的图像文件格式。GIF采用LZW压缩算法来存储图象数据，并采用了可变长度等压缩算法。GIF的图像深度从1 bit到8 bit，也即GIF最多支持256种颜色的图像。GIF格式的另一个特点是其在一个GIF文件中可以存多幅彩色图像，如果把存于一个文件中的多幅图像数据逐幅读出并显示到屏幕上，就可构成一种最简单的动画</p>
<p>​	<code>.tif</code>：pTIF格式可说是做平面设计上最常使用到的一种图形格式，因为是属于跨平台的格式，而且支持cmyk色，所以经常被用于印刷输出的场合。此外还有一个特色就是支持lzw压缩，属于无损压缩。TIFF（Tag Image File Format，Tag Image File Format）文件是由Aldus和Microsoft公司为扫描仪和桌上出版系统研制开发的一种较为通用的图像文件格式。TIFF支持多种编码方法，其中包括RGB无压缩、RLE压缩及JPEG压缩等</p>
<p>​	<code>.svg</code>：SVG全称为Scalable Vector Graphics，意思为可缩放的<strong>矢量图形</strong>。它是基于XML（Extensible Markup Language），由World Wide Web Consortium（W3C）联盟进行开发的。严格来说应该是一种开放标准的矢量图形语言，可让你设计高分辨率的Web图形页面。用户可以直接用代码来描绘图像，可以用任何文字处理工具打开SVG图像，通过改变部分代码来使图像具有互交功能，并可以随时插入到HTML中通过浏览器来观看</p>
<h1 id="JPEG"><a href="#JPEG" class="headerlink" title="JPEG"></a>JPEG</h1><p>​	<strong>本文主要内容关于将JPEG用于无线通信中，所以仅简单介绍JPEG的基本原理</strong></p>
<p>​	JPEG(Joint Photographic Experts Group)算法会分析图片的各个部分，找到并删除人眼不易察觉的元素。当使用JPEG算法压缩图片时，可以选一个叫“质量”(Quality)的可变数值来决定压缩的程度，当图像的质量从100%下降到0%时，图片文件的压缩程度也随之越来越高，从而减小了图片文件所占的空间。但是JPEG并不会改变图片的分辨率、像素数量。当图片压缩得越来越小时，可以看到图片的分辨率或像素的数量保持不变。但最终我们会得到这些有缺陷的方块，技术上叫“膺像”(artifacts)</p>
<p>​	JPEG算法有5个步骤组成：</p>
<ul>
<li>Color Space Conversion：色彩空间转换。从RGB转为YUV色彩空间。这个过程是可逆的，在转换过程中没有删除任何数据。Y亮度，Cb蓝色色度、Cr红色色度</li>
<li>Chrominance Downsampling：色度缩减取样。将蓝色色度和红色色度分量层上的像素按照2×2个像素成一个区块划分，然后计算每个区块的色度平均值，并删掉重复的信息，然后缩小图像，使得含有一个平均值的由4个像素组成的区块只占一个像素的空间。因此那些我们眼睛不易感知的红蓝色度信息的量被缩减到原来的四分之一，而亮度保持不变，这样就导致图像的大小变成原来的一半。但是当我们查看图片时，蓝色和红色色度图层会被放大到跟亮度图层一样的大小，并根据亮度、蓝色色度、红色色度的值重新计算出RGB的值，由于各个像素的亮度可能不同，重新计算的各个像素上的RGB值也可能有变化</li>
<li>Discrete Cosine Transform(DCT)：离散余弦变换。人眼不擅长感知图像中的高频率元素，遍历图像的各个部分，并找到具有高频率的色度或亮度的像素频繁出现的区域，然后将这些人眼很难感知的元素删除。DCT不能压缩或缩小图像。基本思想是提取原始图像的某个通道如亮度（其余通道也做同样操作），将该通道分成多block，每个block是8×8像素，将像素值减去128，取值范围变为-128~127。敲定一个基础图像，将基础图像乘一个系数相加64次，每次系数不同，原始的64个像素变成64个系数</li>
<li>Quantization：量化。经过DCT拥有一个8×8的常数表，对应于每个基础图像的使用情况。将常数表中的各个值除以量化表中的对应值，并将每个结果四舍五入为最接近的整数。量化表右下角数值较高，那里有人眼不擅长感知的高频数据，而数据较小的左上角，是人眼更易区分的样式所在。这样最后结果有很多0，这些是我们扔掉的人眼无法感知的数据。整张图像使用了一组相同的64个基础图像和两个量化表（一个用于亮度，另一个用于色度），以便将各个8×8的像素区块转化为几个数字和一大堆的0。<strong>压缩程度Quality就是改变量化表中的数值</strong></li>
<li>Run Length and Huffman Encoding：游程编码&#x2F;哈夫曼编码。列出所有区块中的亮度和色度数值，但是采取之字形顺序，因为这样更有可能找到一连串的非0数。接下来在列出的数字中，使用游程编码算法，不列出所有的0，只是说有多少个0。这个只有十几个数字的列表，比64个像素分别由一个0~255的数字来表示的方法要压缩得多。之后使用霍夫曼编码。</li>
</ul>
<p>​	JPEG解压缩上述步骤相反</p>
<h1 id="JPEG文件存储格式"><a href="#JPEG文件存储格式" class="headerlink" title="JPEG文件存储格式"></a>JPEG文件存储格式</h1><p>​	JPEG本身只有描述如何将一个视频&#x2F;图片转换为字节的数据流（streaming），但并没有说明这些字节如何在任何特定的存储媒体上被封存起来</p>
<p>​	这里要对JPEG做一个补充说明，很多人把JPEG标准和JPEG文件格式理解成一个东西。然而实际并不是这样的，JPEG标准主要还是围绕编解码的部分（如DCT变换、量化、哈夫曼树等等），虽然在JPEG标准中也定义了“JPEG Interchange Format (JIF)”的文件存储格式，但是因为Encoder和Decoder完整实现JIF很困难，且JIF标准也存在一些缺陷，因此JIF并没有被推广开来。倒是后来出现的“**JPEG File Interchange Format (JFIF)<strong>” 和 “</strong>Exchange image file Format(Exif)**” 等新的存储格式成为了主流。Exif 也好 JFIF 也罢，他们都是遵循 JIF标准的，两者只是在JIF的基础上增加了一些各自的Marker</p>
<ul>
<li>JPEG是压缩标准，JPEG&#x2F;JFIF和JPEG&#x2F;EXIF是文件格式标准，不是一个概念，需要注意区分</li>
<li>JPEG&#x2F;EXIF文件格式标准是Camera产业联合会发布，主要用于摄像设备上，摄像产业把EXIF作为行业的元数据（metadata)交换格式</li>
<li>JPEG&#x2F;JFIF文件格式标准是为了方便JPEG压缩图像在广泛的平台和应用间以最小的存储空间代价进行交换而设计的，它不包含JPEG&#x2F;TIFF标准任何高级特性</li>
</ul>
<p>​	<strong>实际上EXIF作为数码相机独特存储的数据格式，添加在JFIF数据格式的APPn上</strong>		</p>
<p>​	相比于BMP文件结构，JPEG文件结构要复杂得多。由于Exif和JFIF格式的都是遵循JIF的标准，在存储格式上沿袭了统一的 <code>JPEG Marker</code> + <code>Compressed Data</code> 的方式。整个文件根据不同的Marker划分成不同的<code>标记段</code>。每个Marker的长度为固定的 2 Byte</p>
<table>
<thead>
<tr>
<th align="left">Marker名称</th>
<th align="left">Marker内容</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">SOI</td>
<td align="left">0xFFD8</td>
<td align="left">Start Of Image</td>
</tr>
<tr>
<td align="left">SOF0</td>
<td align="left">0xFFC0</td>
<td align="left">Start Of Frame 0</td>
</tr>
<tr>
<td align="left">SOF2</td>
<td align="left">0xFFC2</td>
<td align="left">Start of Frame 2</td>
</tr>
<tr>
<td align="left">DHT</td>
<td align="left">0xFFC4</td>
<td align="left">Define Huffman Table(s)</td>
</tr>
<tr>
<td align="left">DQT</td>
<td align="left">0xFFDB</td>
<td align="left">Define Quantization Table(s)</td>
</tr>
<tr>
<td align="left">DRI</td>
<td align="left">0xFFDD</td>
<td align="left">Define Restart Interval</td>
</tr>
<tr>
<td align="left">SOS</td>
<td align="left">0xFFDA</td>
<td align="left">Start of Scan</td>
</tr>
<tr>
<td align="left">RST0~RST7</td>
<td align="left">0xFFD0 ~ 0xFFD7</td>
<td align="left">Restart</td>
</tr>
<tr>
<td align="left">APP0~APP15</td>
<td align="left">0xFFE0 ~ 0xFFEF</td>
<td align="left">Application-sepcific</td>
</tr>
<tr>
<td align="left">COM</td>
<td align="left">0xFFFE</td>
<td align="left">Comment</td>
</tr>
<tr>
<td align="left">EOI</td>
<td align="left">0xFFD9</td>
<td align="left">End of Image</td>
</tr>
</tbody></table>
<p>​	上面这张表列举了JPEG 的主要 Marker。文件按照Marker的划分成不同的<code>标记段</code>，每个<code>标记段</code>结构轮廓一致，如下图所示。<code>Detail Data</code> 部分的结构根据不同的Marker的定义而进行不同的细分</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/pCHWkGV"><img src="https://s1.ax1x.com/2023/07/20/pCHWkGV.jpg" alt="pCHWkGV.jpg" style="zoom: 80%;" /></a></p>
<p>​	SOI (0xFFD8) 和 EOI (0xFFD9) 作为JPEG文件的起止标志，不参照上图的数据划分。所有的JPEG文件的头两个字节一定是 0xFFD8 最后两个字节是 0xFFD9</p>
<p>​	<strong>JPEG文件格式详细介绍：</strong></p>
<p>JPEG文件的存储格式有很多种，但最常用的是JFIF格式，即JPEG File Interchange Format。JPEG文件大体可以分为两个部分：</p>
<p>（1）标记码；由两个字节构成，其中，前一个字节是固定值0XFF代表了一个标记码的开始，后一个字节不同的值代表着不同的含义。需要提醒的是，连续的多个0XFF可以理解为一个0XFF，并表示一个标记码的开始。另外，标记码在文件中一般是以标记代码的形式出现的。例如，SOI的标记代码是0XFFD8，即，如果JPEG文件中出现了0XFFD8，则代表此处是一个SOI标记。</p>
<p>（2）压缩数据；一个完整的两字节标记码的后面，就是该标记码对应的压缩数据了，它记录了关于文件的若干信息。</p>
<p>一些典型的标记码，及其所代表的含义如下所示：</p>
<p>SOI，Start Of Image， 图像开始，标记代码为固定值0XFFD8，用2字节表示；</p>
<p>APP0，Application 0, 应用程序保留标记0，标记代码为固定值0XFFE0，用2字节表示；该标记码之后包含了9个具体的字段：</p>
<p>（1）数据长度：2个字节，用来表示（1）–（9）的9个字段的总长度，即不包含标记代码但包含本字段；</p>
<p>（2）标示符：5个字节，固定值0X4A6494600，表示了字符串“JFIF0”；</p>
<p>（3）版本号：2个字节，一般为0X0102，表示JFIF的版本号为1.2；但也可能为其它数值，从而代表了其它版本号；</p>
<p>（4）X,Y方向的密度单位：1个字节，只有三个值可选，0：无单位；1：点数每英寸；2：点数每厘米；</p>
<p>（5）X方向像素密度：2个字节，取值范围未知；</p>
<p>（6）Y方向像素密度：2个字节，取值范围未知；</p>
<p>（7）缩略图水平像素数目：1个字节，取值范围未知；</p>
<p>（8）缩略图垂直像素数目：1个字节，取值范围未知；</p>
<p>（9）缩略图RGB位图：长度可能是3的倍数，保存了一个24位的RGB位图；如果没有缩略位图（这种情况更常见），则字段（7）（8）的取值均为0；</p>
<p>APPn, Application n, 应用程序保留标记n(n&#x3D;1—15),标记代码为2个字节，取值为0XFFE1–0XFFFF；包含了两个字段：</p>
<p>（1）数据长度，2个字节，表示（1）（2）两个字段的总长度；即，不包含标记代码，但包含本字段；</p>
<p>（2）详细信息：数据长度-2个字节，内容不定；</p>
<p>DQT，Define Quantization Table, 定义量化表；标记代码为固定值0XFFDB；包含9个具体字段：</p>
<p>（1）数据长度：2个字节，表示（1）和多个（2）字段的总长度；即，不包含标记代码，但包含本字段；</p>
<p>（2）量化表：数据长度-2个字节，其中包括以下内容：</p>
<p>（a）精度及量化表ID，1个字节，高4位表示精度，只有两个可选值，0：8位；1:16位；低4位表示量化表ID，取值范围为0–3；</p>
<p>（b）表项，64<em>（精度取值+1）个字节，例如，8位精度的量化表，其表项长度为64</em>（0+1）&#x3D;64字节；</p>
<p>本标记段中，（2）可以重复出现，表示多个量化表，但最多只能出现4次；</p>
<p>SOFO，Start Of Frame, 帧图像开始，标记代码为固定值0XFFC0；包含9个具体字段：</p>
<p>（1）数据长度：2个字节，（1）–（6）共6个字段的总长度；即，不包含标记代码，但包含本字段；</p>
<p>（2）精度：1个字节，代表每个数据样本的位数；通常是8位；</p>
<p>（3）图像高度：2个字节，表示以像素为单位的图像高度，如果不支持DNL就必须大于0；</p>
<p>（4）图像宽度：2个字节，表示以像素为单位的图像宽度，如果不支持DNL就必须大于0；</p>
<p>（5）颜色分量个数：1个字节，由于JPEG采用YCrCb颜色空间，这里恒定为3；</p>
<p>（6）颜色分量信息：颜色分量个数*3个字节，这里通常为9个字节；并依此表示如下一些信息：</p>
<p>（a）颜色分量ID： 1个字节；</p>
<p>（b）水平&#x2F;垂直采样因子：1个字节，高4位代表水平采样因子，低4位代表垂直采样因子；</p>
<p>（c）量化表：1个字节，当前分量使用的量化表ID；</p>
<p>本标记段中，字段（6）应该重复出现3次，因为这里有3个颜色分量；</p>
<p>DHT，Define Huffman Table定义Huffman表，标记码为0XFFC4；包含2个字段：</p>
<p>（1）数据长度，2个字节，表示（1）–（2）的总长度，即，不包含标记代码，但包含本字段；</p>
<p>（2）Huffman表，数据长度-2个字节，包含以下字段：</p>
<p>（a）表ID和表类型，1个字节，高4位表示表的类型，取值只有两个；0：DC直流；1：AC交流；低4位，Huffman表ID；需要提醒的是，DC表和AC表分开进行编码；</p>
<p>（b）不同位数的码字数量，16个字节；</p>
<p>（c）编码内容，16个不同位数的码字数量之和（字节）；</p>
<p>本标记段中，字段（2）可以重复出现，一般需要重复4次。</p>
<p>DRI，Define Restart Interval，定义差分编码累计复位的间隔，标记码为固定值0XFFDD；</p>
<p>包含2个具体字段：</p>
<p>（1）数据长度：2个字节，取值为固定值0X0004，表示（1）（2）两个字段的总长度；即，不包含标记代码，但包含本字段；</p>
<p>（2）MCU块的单元中重新开始间隔：2个字节，如果取值为n，就代表每n个MCU块就有一个RSTn标记；第一个标记是RST0，第二个是RST1,RST7之后再从RST0开始重复；如果没有本标记段，或者间隔值为0，就表示不存在重开始间隔和标记RST；</p>
<p>SOS，Start Of Scan，扫描开始；标记码为0XFFDA，包含2个具体字段：</p>
<p>（1）数据长度：2个字节，表示（1）–（4）字段的总长度；</p>
<p>（2）颜色分量数目：1个字节，只有3个可选值，1：灰度图；3：YCrCb或YIQ；4：CMYK；</p>
<p>（3）颜色分量信息：包括以下字段，</p>
<p>（a）颜色分量ID：1个字节；</p>
<p>（b）直流&#x2F;交流系数表ID，1个字节，高4位表示直流分量的Huffman表的ID；低4位表示交流分量的Huffman表的ID；</p>
<p>（4）压缩图像数据</p>
<p>（a）谱选择开始：1个字节，固定值0X00；</p>
<p>（b）谱选择结束：1个字节，固定值0X3F；</p>
<p>（c）谱选择：1个字节，固定值0X00；</p>
<p>本标记段中，（3）应该重复出现，有多少个颜色分量，就重复出现几次；本段结束之后，就是真正的图像信息了；图像信息直到遇到EOI标记就结束了；</p>
<p>EOI，End Of Image，图像结束；标记代码为0XFFD9；</p>
<p>另外，需要说明的是，在JPEG中0XFF具有标记的意思，所以在压缩数据流（真正的图像信息）中，如果出现了0XFF，就需要做特别处理了。方法是，如果在图像数据流中遇到0XFF，应该检测其紧接着的字符，如果是：</p>
<p>（1）0X00，表示0XFF是图像流的组成部分；需要进行译码；</p>
<p>（2）0XD9，表示与0XFF组成标记EOI，即，代表图像流的结束，同时，图像文件结束；</p>
<p>（3）0XD0–0XD7，组成RSTn标记，需要忽视整个RSTn标记，即不对当前0XFF和紧接着的0XDn两个字节进行译码，并按RST标记的规则调整译码变量；</p>
<p>（4）0XFF，忽略当前0XFF，对后一个0XFF进行判断；</p>
<p>（5）其它数值，忽然当前0XFF，并保留紧接着此数值用于译码；</p>
<p>​	需要说明的是，JPEG文件格式中，一个字（16位）的存储使用的是Motorola格式，而不是Intel格式。也就是说，一个字的高字节（高8位）在数据流的前面，低字节（低8位）在数据流的后面，与平时习惯的Intel格式有所不同。这种字节顺序问题的起因在于早期的硬件发展上。在8位CPU的时代，许多8位CPU都可以处理16位的数据，但它们显然是分两次进行处理的。这个时候就出现了先处理高位字节还是先处理低位字节的问题。以Intel为代表的厂家生产的CPU采用先低字节后高字节的方式；而以Motorola,IBM为代表的厂家生产的CPU则采用了先高字节后低字节的方式。Intel的字节顺序也称为little-endian，而Motorola的字节顺序就叫做big-endian。而JPEG&#x2F;JFIF文件格式则采用了big-endian格式。下面的函数，实现了从intel格式到motolora格式的转换</p>
<h1 id="JPEG用于无线图像传输"><a href="#JPEG用于无线图像传输" class="headerlink" title="JPEG用于无线图像传输"></a>JPEG用于无线图像传输</h1><p>​	常用的JPEG算法库：opencv、simplejpeg、PyTurboJPEG等。这些算法库提供JPEG压缩和解压缩的API，当需要将原图进行压缩并存储时可以直接使用这些算法库实现。使用案例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;source1.jpg&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># cv2.imencode(&#x27;.jpg&#x27;, img, [int(cv2.IMWRITE_JPEG_QUALITY), 95]) # 这种写法的95是图像质量，不写这个参数默认95</span></span><br><span class="line"><span class="comment"># 默认图像质量为95</span></span><br><span class="line">img_encode = cv2.imencode(<span class="string">&#x27;.jpg&#x27;</span>, img)[<span class="number">1</span>]  <span class="comment"># &#x27;.jpg&#x27;表示把当前图片img按照jpg格式编码，按照不同格式编码的结果不一样  imgg = cv2.imencode(&#x27;.png&#x27;, img)</span></span><br><span class="line"><span class="built_in">print</span>(img_encode)</span><br><span class="line">str_encode = img_encode.tobytes()</span><br><span class="line"><span class="comment"># 缓存数据保存到本地，以txt格式保存</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;img_encode.txt&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(str_encode)</span><br><span class="line">    f.flush()</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;img_encode.txt&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    str_encode = f.read()</span><br><span class="line"></span><br><span class="line">nparr = np.frombuffer(str_encode, np.uint8)  <span class="comment"># ndarray格式</span></span><br><span class="line">img_decode = cv2.imdecode(nparr, cv2.IMREAD_COLOR)</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&quot;img_decode&quot;</span>, img_decode)</span><br><span class="line">cv2.waitKey()</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"># 读取图像</span></span><br><span class="line"><span class="string">img = cv2.imread(&#x27;source1.jpg&#x27;)</span></span><br><span class="line"><span class="string">print(img.shape)</span></span><br><span class="line"><span class="string"># 2624400</span></span><br><span class="line"><span class="string"># 将图像编码为JPEG格式二进制数据</span></span><br><span class="line"><span class="string">retval, buffer = cv2.imencode(&#x27;.jpg&#x27;, img, [int(cv2.IMWRITE_JPEG_QUALITY), 95])</span></span><br><span class="line"><span class="string">#retval, buffer = cv2.imencode(&#x27;.jpg&#x27;, img)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">print(buffer.shape)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 将二进制数据写入文件</span></span><br><span class="line"><span class="string">with open(&#x27;image_encoded.jpg&#x27;, &#x27;wb&#x27;) as f:</span></span><br><span class="line"><span class="string">    f.write(buffer)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>​	直接调用已有的算法库缺点是无法了解底层实现机制。这只是小问题，<strong>主要问题是无法直接用于无线通信，因为JPEG算法库提供的API都是将原图直接压缩成.jpg文件，支持在windows等系统上使用图像查看软件直接打开查看，虽然能直接打开查看压缩结果是一种优势，但这也意味着图像文件中包含了很多必要的Marker。如果将其在无线环境中传输，一旦Marker受损，则无法实现JPEG解压缩，理想情况是只有原始图像数据压缩后的数据受损，而Marker部分不受损才能实现解压缩，这在较差的实际环境中几乎不可能实现。而且在物理层传输对象是比特流，在通信系统中还需要使用信道编码降低误码率。因此不得不自己编写适用于无线环境传输的JPEG算法，即便是这样，也需要假设用于解压缩的一些关键信息在接收端无差错接收</strong>。因此参考网上已有的使用python实现JPEG算法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">KJPEG</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化DCT变换的A矩阵</span></span><br><span class="line">        <span class="comment"># 该矩阵用于控制压缩率，离散余弦变换是无损的</span></span><br><span class="line">        self.__dctA = np.zeros(shape=(<span class="number">8</span>, <span class="number">8</span>))  <span class="comment"># 8*8</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">            c = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                c = np.sqrt(<span class="number">1</span> / <span class="number">8</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                c = np.sqrt(<span class="number">2</span> / <span class="number">8</span>)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">                self.__dctA[i, j] = c * np.cos(np.pi * i * (<span class="number">2</span> * j + <span class="number">1</span>) / (<span class="number">2</span> * <span class="number">8</span>))</span><br><span class="line">        <span class="comment"># 亮度量化矩阵</span></span><br><span class="line">        self.__lq = np.array([</span><br><span class="line">            <span class="number">16</span>, <span class="number">11</span>, <span class="number">10</span>, <span class="number">16</span>, <span class="number">24</span>, <span class="number">40</span>, <span class="number">51</span>, <span class="number">61</span>,</span><br><span class="line">            <span class="number">12</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">19</span>, <span class="number">26</span>, <span class="number">58</span>, <span class="number">60</span>, <span class="number">55</span>,</span><br><span class="line">            <span class="number">14</span>, <span class="number">13</span>, <span class="number">16</span>, <span class="number">24</span>, <span class="number">40</span>, <span class="number">57</span>, <span class="number">69</span>, <span class="number">56</span>,</span><br><span class="line">            <span class="number">14</span>, <span class="number">17</span>, <span class="number">22</span>, <span class="number">29</span>, <span class="number">51</span>, <span class="number">87</span>, <span class="number">80</span>, <span class="number">62</span>,</span><br><span class="line">            <span class="number">18</span>, <span class="number">22</span>, <span class="number">37</span>, <span class="number">56</span>, <span class="number">68</span>, <span class="number">109</span>, <span class="number">103</span>, <span class="number">77</span>,</span><br><span class="line">            <span class="number">24</span>, <span class="number">35</span>, <span class="number">55</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">104</span>, <span class="number">113</span>, <span class="number">92</span>,</span><br><span class="line">            <span class="number">49</span>, <span class="number">64</span>, <span class="number">78</span>, <span class="number">87</span>, <span class="number">103</span>, <span class="number">121</span>, <span class="number">120</span>, <span class="number">101</span>,</span><br><span class="line">            <span class="number">72</span>, <span class="number">92</span>, <span class="number">95</span>, <span class="number">98</span>, <span class="number">112</span>, <span class="number">100</span>, <span class="number">103</span>, <span class="number">99</span>,</span><br><span class="line">        ])</span><br><span class="line">        <span class="comment"># 色度量化矩阵</span></span><br><span class="line">        self.__cq = np.array([</span><br><span class="line">            <span class="number">17</span>, <span class="number">18</span>, <span class="number">24</span>, <span class="number">47</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>,</span><br><span class="line">            <span class="number">18</span>, <span class="number">21</span>, <span class="number">26</span>, <span class="number">66</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>,</span><br><span class="line">            <span class="number">24</span>, <span class="number">26</span>, <span class="number">56</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>,</span><br><span class="line">            <span class="number">47</span>, <span class="number">66</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>,</span><br><span class="line">            <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>,</span><br><span class="line">            <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>,</span><br><span class="line">            <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>,</span><br><span class="line">            <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>,</span><br><span class="line">        ])</span><br><span class="line">        <span class="comment"># 标记矩阵类型，lt是亮度矩阵，ct是色度矩阵</span></span><br><span class="line">        self.__lt = <span class="number">0</span></span><br><span class="line">        self.__ct = <span class="number">1</span></span><br><span class="line">        <span class="comment"># Zig编码表</span></span><br><span class="line">        self.__zig = np.array([</span><br><span class="line">            <span class="number">0</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">10</span>,</span><br><span class="line">            <span class="number">17</span>, <span class="number">24</span>, <span class="number">32</span>, <span class="number">25</span>, <span class="number">18</span>, <span class="number">11</span>, <span class="number">4</span>, <span class="number">5</span>,</span><br><span class="line">            <span class="number">12</span>, <span class="number">19</span>, <span class="number">26</span>, <span class="number">33</span>, <span class="number">40</span>, <span class="number">48</span>, <span class="number">41</span>, <span class="number">34</span>,</span><br><span class="line">            <span class="number">27</span>, <span class="number">20</span>, <span class="number">13</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">14</span>, <span class="number">21</span>, <span class="number">28</span>,</span><br><span class="line">            <span class="number">35</span>, <span class="number">42</span>, <span class="number">49</span>, <span class="number">56</span>, <span class="number">57</span>, <span class="number">50</span>, <span class="number">43</span>, <span class="number">36</span>,</span><br><span class="line">            <span class="number">29</span>, <span class="number">22</span>, <span class="number">15</span>, <span class="number">23</span>, <span class="number">30</span>, <span class="number">37</span>, <span class="number">44</span>, <span class="number">51</span>,</span><br><span class="line">            <span class="number">58</span>, <span class="number">59</span>, <span class="number">52</span>, <span class="number">45</span>, <span class="number">38</span>, <span class="number">31</span>, <span class="number">39</span>, <span class="number">46</span>,</span><br><span class="line">            <span class="number">53</span>, <span class="number">60</span>, <span class="number">61</span>, <span class="number">54</span>, <span class="number">47</span>, <span class="number">55</span>, <span class="number">62</span>, <span class="number">63</span></span><br><span class="line">        ])</span><br><span class="line">        <span class="comment"># Zag编码表</span></span><br><span class="line">        self.__zag = np.array([</span><br><span class="line">            <span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">27</span>, <span class="number">28</span>,</span><br><span class="line">            <span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">13</span>, <span class="number">16</span>, <span class="number">26</span>, <span class="number">29</span>, <span class="number">42</span>,</span><br><span class="line">            <span class="number">3</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">17</span>, <span class="number">25</span>, <span class="number">30</span>, <span class="number">41</span>, <span class="number">43</span>,</span><br><span class="line">            <span class="number">9</span>, <span class="number">11</span>, <span class="number">18</span>, <span class="number">24</span>, <span class="number">31</span>, <span class="number">40</span>, <span class="number">44</span>, <span class="number">53</span>,</span><br><span class="line">            <span class="number">10</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">32</span>, <span class="number">39</span>, <span class="number">45</span>, <span class="number">52</span>, <span class="number">54</span>,</span><br><span class="line">            <span class="number">20</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">38</span>, <span class="number">46</span>, <span class="number">41</span>, <span class="number">55</span>, <span class="number">60</span>,</span><br><span class="line">            <span class="number">21</span>, <span class="number">34</span>, <span class="number">37</span>, <span class="number">47</span>, <span class="number">50</span>, <span class="number">56</span>, <span class="number">59</span>, <span class="number">61</span>,</span><br><span class="line">            <span class="number">35</span>, <span class="number">36</span>, <span class="number">48</span>, <span class="number">49</span>, <span class="number">57</span>, <span class="number">58</span>, <span class="number">62</span>, <span class="number">63</span></span><br><span class="line">        ])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__Rgb2Yuv</span>(<span class="params">self, r, g, b</span>):</span><br><span class="line">        <span class="comment"># 从图像获取YUV矩阵</span></span><br><span class="line">        y = <span class="number">0.299</span> * r + <span class="number">0.587</span> * g + <span class="number">0.114</span> * b</span><br><span class="line">        u = -<span class="number">0.1687</span> * r - <span class="number">0.3313</span> * g + <span class="number">0.5</span> * b + <span class="number">128</span></span><br><span class="line">        v = <span class="number">0.5</span> * r - <span class="number">0.419</span> * g - <span class="number">0.081</span> * b + <span class="number">128</span></span><br><span class="line">        <span class="keyword">return</span> y, u, v</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__Fill</span>(<span class="params">self, matrix</span>):</span><br><span class="line">        <span class="comment"># 图片的长宽都需要满足是16的倍数（采样长宽会缩小1/2和取块长宽会缩小1/8）</span></span><br><span class="line">        <span class="comment"># 图像压缩三种取样方式4:4:4、4:2:2、4:2:0</span></span><br><span class="line">        fh, fw = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> self.height % <span class="number">16</span> != <span class="number">0</span>:</span><br><span class="line">            fh = <span class="number">16</span> - self.height % <span class="number">16</span></span><br><span class="line">        <span class="keyword">if</span> self.width % <span class="number">16</span> != <span class="number">0</span>:</span><br><span class="line">            fw = <span class="number">16</span> - self.width % <span class="number">16</span></span><br><span class="line">        res = np.pad(matrix, ((<span class="number">0</span>, fh), (<span class="number">0</span>, fw)), <span class="string">&#x27;constant&#x27;</span>,</span><br><span class="line">                             constant_values=(<span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__Encode</span>(<span class="params">self, matrix, tag</span>):</span><br><span class="line">        <span class="comment"># 先对矩阵进行填充</span></span><br><span class="line">        matrix = self.__Fill(matrix)</span><br><span class="line">        <span class="comment"># 将图像矩阵切割成8*8小块</span></span><br><span class="line">        height, width = matrix.shape</span><br><span class="line">        <span class="comment"># 减少for循环语句，利用numpy的自带函数来提升算法效率</span></span><br><span class="line">        <span class="comment"># 参考吴恩达的公开课视频，numpy的函数自带并行处理，不用像for循环一样串行处理</span></span><br><span class="line">        shape = (height // <span class="number">8</span>, width // <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>)  <span class="comment"># (28, 28, 8, 8)</span></span><br><span class="line">        strides = matrix.itemsize * np.array([width * <span class="number">8</span>, <span class="number">8</span>, width, <span class="number">1</span>])</span><br><span class="line">        blocks = np.lib.stride_tricks.as_strided(matrix, shape=shape, strides=strides)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment"># 对每个8*8的block做处理</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(height // <span class="number">8</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(width // <span class="number">8</span>):</span><br><span class="line">                res.append(self.__Quantize(self.__Dct(blocks[i, j]).reshape(<span class="number">64</span>), tag))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__Dct</span>(<span class="params">self, block</span>):</span><br><span class="line">        <span class="comment"># DCT变换</span></span><br><span class="line">        res = np.dot(self.__dctA, block)</span><br><span class="line">        res = np.dot(res, np.transpose(self.__dctA))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__Quantize</span>(<span class="params">self, block, tag</span>):</span><br><span class="line">        res = block</span><br><span class="line">        <span class="keyword">if</span> tag == self.__lt:</span><br><span class="line">            res = np.<span class="built_in">round</span>(res / self.__lq)</span><br><span class="line">        <span class="keyword">elif</span> tag == self.__ct:</span><br><span class="line">            res = np.<span class="built_in">round</span>(res / self.__cq)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__Zig</span>(<span class="params">self, blocks</span>):</span><br><span class="line">        ty = np.array(blocks)  <span class="comment"># 784*64</span></span><br><span class="line">        tz = np.zeros(ty.shape)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.__zig)):</span><br><span class="line">            tz[:, i] = ty[:, self.__zig[i]]</span><br><span class="line">        tz = tz.reshape(tz.shape[<span class="number">0</span>] * tz.shape[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> tz.tolist()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__Rle</span>(<span class="params">self, blist</span>):</span><br><span class="line">        <span class="comment"># blist是50176的list列表，3个，分别为yuv</span></span><br><span class="line">        res = []</span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(blist)):</span><br><span class="line">            <span class="keyword">if</span> blist[i] != <span class="number">0</span>:</span><br><span class="line">                res.append(cnt)</span><br><span class="line">                res.append(<span class="built_in">int</span>(blist[i]))</span><br><span class="line">                cnt = <span class="number">0</span></span><br><span class="line">            <span class="keyword">elif</span> cnt == <span class="number">15</span>:</span><br><span class="line">                res.append(cnt)</span><br><span class="line">                res.append(<span class="built_in">int</span>(blist[i]))</span><br><span class="line">                cnt = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 末尾全是0的情况</span></span><br><span class="line">        <span class="keyword">if</span> cnt != <span class="number">0</span>:</span><br><span class="line">            res.append(cnt - <span class="number">1</span>)</span><br><span class="line">            res.append(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Compress</span>(<span class="params">self, filename</span>):</span><br><span class="line">        <span class="comment"># 根据路径image_path读取图片，并存储为RGB矩阵</span></span><br><span class="line">        image = Image.<span class="built_in">open</span>(filename)</span><br><span class="line">        <span class="comment"># 获取图片宽度width和高度height</span></span><br><span class="line">        self.width, self.height = image.size</span><br><span class="line">        image = image.convert(<span class="string">&#x27;RGB&#x27;</span>)</span><br><span class="line">        image = np.asarray(image)</span><br><span class="line"></span><br><span class="line">        r = image[:, :, <span class="number">0</span>]</span><br><span class="line">        g = image[:, :, <span class="number">1</span>]</span><br><span class="line">        b = image[:, :, <span class="number">2</span>]</span><br><span class="line">        <span class="comment"># 将图像RGB转YUV</span></span><br><span class="line">        y, u, v = self.__Rgb2Yuv(r, g, b)  <span class="comment"># (224, 224)</span></span><br><span class="line">        <span class="comment"># 对图像矩阵进行编码</span></span><br><span class="line">        y_blocks = self.__Encode(y, self.__lt)  <span class="comment"># 784长度的list，每个元素是一个block编码后结果</span></span><br><span class="line">        u_blocks = self.__Encode(u, self.__ct)</span><br><span class="line">        v_blocks = self.__Encode(v, self.__ct)</span><br><span class="line">        <span class="comment"># 对图像小块进行Zig编码和RLE编码</span></span><br><span class="line">        y_code = self.__Rle(self.__Zig(y_blocks))  <span class="comment"># 29948</span></span><br><span class="line">        u_code = self.__Rle(self.__Zig(u_blocks))  <span class="comment"># 8650</span></span><br><span class="line">        v_code = self.__Rle(self.__Zig(v_blocks))  <span class="comment"># 8046</span></span><br><span class="line">        <span class="comment"># 计算VLI可变字长整数编码并写入文件，未实现Huffman部分</span></span><br><span class="line">        buff = <span class="number">0</span></span><br><span class="line">        tfile = os.path.splitext(filename)[<span class="number">0</span>] + <span class="string">&quot;.gpj&quot;</span></span><br><span class="line">        <span class="keyword">if</span> os.path.exists(tfile):</span><br><span class="line">            os.remove(tfile)</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(tfile, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> o:</span><br><span class="line">            o.write(self.height.to_bytes(<span class="number">2</span>, byteorder=<span class="string">&#x27;big&#x27;</span>))  <span class="comment"># 2字节高度</span></span><br><span class="line">            o.flush()</span><br><span class="line">            o.write(self.width.to_bytes(<span class="number">2</span>, byteorder=<span class="string">&#x27;big&#x27;</span>))  <span class="comment"># 2字节宽度</span></span><br><span class="line">            o.flush()</span><br><span class="line">            o.write((<span class="built_in">len</span>(y_code)).to_bytes(<span class="number">4</span>, byteorder=<span class="string">&#x27;big&#x27;</span>))  <span class="comment"># 4字节y长度</span></span><br><span class="line">            o.flush()</span><br><span class="line">            o.write((<span class="built_in">len</span>(u_code)).to_bytes(<span class="number">4</span>, byteorder=<span class="string">&#x27;big&#x27;</span>))  <span class="comment"># 4字节u长度</span></span><br><span class="line">            o.flush()</span><br><span class="line">            o.write((<span class="built_in">len</span>(v_code)).to_bytes(<span class="number">4</span>, byteorder=<span class="string">&#x27;big&#x27;</span>))  <span class="comment"># 4字节v长度</span></span><br><span class="line">            o.flush()</span><br><span class="line">        self.__Write2File(tfile, y_code, u_code, v_code)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__Write2File</span>(<span class="params">self, filename, y_code, u_code, v_code</span>):</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&quot;ab+&quot;</span>) <span class="keyword">as</span> o:</span><br><span class="line">            buff = <span class="number">0</span></span><br><span class="line">            bcnt = <span class="number">0</span></span><br><span class="line">            data = y_code + u_code + v_code</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data)):</span><br><span class="line">                <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                    td = data[i]</span><br><span class="line">                    <span class="keyword">for</span> ti <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">                        buff = (buff &lt;&lt; <span class="number">1</span>) | ((td &amp; <span class="number">0x08</span>) &gt;&gt; <span class="number">3</span>)</span><br><span class="line">                        td &lt;&lt;= <span class="number">1</span></span><br><span class="line">                        bcnt += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">if</span> bcnt == <span class="number">8</span>:</span><br><span class="line">                            o.write(buff.to_bytes(<span class="number">1</span>, byteorder=<span class="string">&#x27;big&#x27;</span>))</span><br><span class="line">                            o.flush()</span><br><span class="line">                            buff = <span class="number">0</span></span><br><span class="line">                            bcnt = <span class="number">0</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    td = data[i]</span><br><span class="line">                    vtl, vts = self.__VLI(td)</span><br><span class="line">                    <span class="keyword">for</span> ti <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">                        buff = (buff &lt;&lt; <span class="number">1</span>) | ((vtl &amp; <span class="number">0x08</span>) &gt;&gt; <span class="number">3</span>)</span><br><span class="line">                        vtl &lt;&lt;= <span class="number">1</span></span><br><span class="line">                        bcnt += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">if</span> bcnt == <span class="number">8</span>:</span><br><span class="line">                            o.write(buff.to_bytes(<span class="number">1</span>, byteorder=<span class="string">&#x27;big&#x27;</span>))</span><br><span class="line">                            o.flush()</span><br><span class="line">                            buff = <span class="number">0</span></span><br><span class="line">                            bcnt = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">for</span> ts <span class="keyword">in</span> vts:</span><br><span class="line">                        buff &lt;&lt;= <span class="number">1</span></span><br><span class="line">                        <span class="keyword">if</span> ts == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                            buff |= <span class="number">1</span></span><br><span class="line">                        bcnt += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">if</span> bcnt == <span class="number">8</span>:</span><br><span class="line">                            o.write(buff.to_bytes(<span class="number">1</span>, byteorder=<span class="string">&#x27;big&#x27;</span>))</span><br><span class="line">                            o.flush()</span><br><span class="line">                            buff = <span class="number">0</span></span><br><span class="line">                            bcnt = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> bcnt != <span class="number">0</span>:</span><br><span class="line">                buff &lt;&lt;= (<span class="number">8</span> - bcnt)</span><br><span class="line">                o.write(buff.to_bytes(<span class="number">1</span>, byteorder=<span class="string">&#x27;big&#x27;</span>))</span><br><span class="line">                o.flush()</span><br><span class="line">                buff = <span class="number">0</span></span><br><span class="line">                bcnt = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__IDct</span>(<span class="params">self, block</span>):</span><br><span class="line">        <span class="comment"># IDCT变换</span></span><br><span class="line">        res = np.dot(np.transpose(self.__dctA), block)</span><br><span class="line">        res = np.dot(res, self.__dctA)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__IQuantize</span>(<span class="params">self, block, tag</span>):</span><br><span class="line">        res = block</span><br><span class="line">        <span class="keyword">if</span> tag == self.__lt:</span><br><span class="line">            res *= self.__lq</span><br><span class="line">        <span class="keyword">elif</span> tag == self.__ct:</span><br><span class="line">            res *= self.__cq</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__IFill</span>(<span class="params">self, matrix</span>):</span><br><span class="line">        matrix = matrix[:self.height, :self.width]</span><br><span class="line">        <span class="keyword">return</span> matrix</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__Decode</span>(<span class="params">self, blocks, tag</span>):</span><br><span class="line">        tlist = []</span><br><span class="line">        <span class="keyword">for</span> b <span class="keyword">in</span> blocks:</span><br><span class="line">            b = np.array(b)</span><br><span class="line">            tlist.append(self.__IDct(self.__IQuantize(b, tag).reshape(<span class="number">8</span> ,<span class="number">8</span>)))</span><br><span class="line">        height_fill, width_fill = self.height, self.width</span><br><span class="line">        <span class="keyword">if</span> height_fill % <span class="number">16</span> != <span class="number">0</span>:</span><br><span class="line">            height_fill += <span class="number">16</span> - height_fill % <span class="number">16</span></span><br><span class="line">        <span class="keyword">if</span> width_fill % <span class="number">16</span> != <span class="number">0</span>:</span><br><span class="line">            width_fill += <span class="number">16</span> - width_fill % <span class="number">16</span></span><br><span class="line">        rlist = []</span><br><span class="line">        <span class="keyword">for</span> hi <span class="keyword">in</span> <span class="built_in">range</span>(height_fill // <span class="number">8</span>):</span><br><span class="line">            start = hi * width_fill // <span class="number">8</span></span><br><span class="line">            rlist.append(np.hstack(<span class="built_in">tuple</span>(tlist[start: start + (width_fill // <span class="number">8</span>)])))</span><br><span class="line">        matrix = np.vstack(<span class="built_in">tuple</span>(rlist))</span><br><span class="line">        res = self.__IFill(matrix)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__ReadFile</span>(<span class="params">self, filename</span>):</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> o:</span><br><span class="line">            tb = o.read(<span class="number">2</span>)</span><br><span class="line">            self.height = <span class="built_in">int</span>.from_bytes(tb, byteorder=<span class="string">&#x27;big&#x27;</span>)  <span class="comment"># 1080</span></span><br><span class="line">            tb = o.read(<span class="number">2</span>)</span><br><span class="line">            self.width = <span class="built_in">int</span>.from_bytes(tb, byteorder=<span class="string">&#x27;big&#x27;</span>)  <span class="comment"># 810</span></span><br><span class="line">            tb = o.read(<span class="number">4</span>)</span><br><span class="line">            ylen = <span class="built_in">int</span>.from_bytes(tb, byteorder=<span class="string">&#x27;big&#x27;</span>)  <span class="comment"># 427458</span></span><br><span class="line">            tb = o.read(<span class="number">4</span>)</span><br><span class="line">            ulen = <span class="built_in">int</span>.from_bytes(tb, byteorder=<span class="string">&#x27;big&#x27;</span>)  <span class="comment"># 130636</span></span><br><span class="line">            tb = o.read(<span class="number">4</span>)</span><br><span class="line">            vlen = <span class="built_in">int</span>.from_bytes(tb, byteorder=<span class="string">&#x27;big&#x27;</span>)  <span class="comment"># 125942</span></span><br><span class="line"></span><br><span class="line">            buff = <span class="number">0</span></span><br><span class="line">            bcnt = <span class="number">0</span></span><br><span class="line">            rlist = []</span><br><span class="line">            itag = <span class="number">0</span></span><br><span class="line">            icnt = <span class="number">0</span></span><br><span class="line">            vtl, tb, tvtl = <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(rlist) &lt; ylen + ulen + vlen:</span><br><span class="line">                <span class="keyword">if</span> bcnt == <span class="number">0</span>:</span><br><span class="line">                    tb = o.read(<span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> tb:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    tb = <span class="built_in">int</span>.from_bytes(tb, byteorder=<span class="string">&#x27;big&#x27;</span>)</span><br><span class="line">                    bcnt = <span class="number">8</span></span><br><span class="line">                <span class="keyword">if</span> itag == <span class="number">0</span>:</span><br><span class="line">                    buff = (buff &lt;&lt; <span class="number">1</span>) | ((tb &amp; <span class="number">0x80</span>) &gt;&gt; <span class="number">7</span>)</span><br><span class="line">                    tb &lt;&lt;= <span class="number">1</span></span><br><span class="line">                    bcnt -= <span class="number">1</span></span><br><span class="line">                    icnt += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> icnt == <span class="number">4</span>:</span><br><span class="line">                        rlist.append(buff &amp; <span class="number">0x0F</span>)</span><br><span class="line">                    <span class="keyword">elif</span> icnt == <span class="number">8</span>:</span><br><span class="line">                        vtl = buff &amp; <span class="number">0x0F</span></span><br><span class="line">                        tvtl = vtl</span><br><span class="line">                        itag = <span class="number">1</span></span><br><span class="line">                        buff = <span class="number">0</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    buff = (buff &lt;&lt; <span class="number">1</span>) | ((tb &amp; <span class="number">0x80</span>) &gt;&gt; <span class="number">7</span>)</span><br><span class="line">                    tb &lt;&lt;= <span class="number">1</span></span><br><span class="line">                    bcnt -= <span class="number">1</span></span><br><span class="line">                    tvtl -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> tvtl == <span class="number">0</span> <span class="keyword">or</span> tvtl == -<span class="number">1</span>:</span><br><span class="line">                        rlist.append(self.__IVLI(vtl, <span class="built_in">bin</span>(buff)[<span class="number">2</span>:].rjust(vtl, <span class="string">&#x27;0&#x27;</span>)))</span><br><span class="line">                        itag = <span class="number">0</span></span><br><span class="line">                        icnt = <span class="number">0</span></span><br><span class="line">        y_dcode = rlist[:ylen]</span><br><span class="line">        u_dcode = rlist[ylen:ylen+ulen]</span><br><span class="line">        v_dcode = rlist[ylen+ulen:ylen+ulen+vlen]</span><br><span class="line">        <span class="keyword">return</span> y_dcode, u_dcode, v_dcode</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__Zag</span>(<span class="params">self, dcode</span>):</span><br><span class="line">        dcode = np.array(dcode).reshape((<span class="built_in">len</span>(dcode) // <span class="number">64</span>, <span class="number">64</span>))</span><br><span class="line">        tz = np.zeros(dcode.shape)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.__zag)):</span><br><span class="line">            tz[:, i] = dcode[:, self.__zag[i]]</span><br><span class="line">        rlist = tz.tolist()</span><br><span class="line">        <span class="keyword">return</span> rlist</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__IRle</span>(<span class="params">self, dcode</span>):</span><br><span class="line">        rlist = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(dcode)):</span><br><span class="line">            <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                rlist += [<span class="number">0</span>] * dcode[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                rlist.append(dcode[i])</span><br><span class="line">        <span class="keyword">return</span> rlist</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Decompress</span>(<span class="params">self, filename</span>):</span><br><span class="line">        y_dcode, u_dcode, v_dcode = self.__ReadFile(filename)</span><br><span class="line"></span><br><span class="line">        y_blocks = self.__Zag(self.__IRle(y_dcode))  <span class="comment"># 784*64 list</span></span><br><span class="line">        u_blocks = self.__Zag(self.__IRle(u_dcode))</span><br><span class="line">        v_blocks = self.__Zag(self.__IRle(v_dcode))</span><br><span class="line"><span class="comment">#############################</span></span><br><span class="line"><span class="comment"># y_blocks、u_blocks和v_blocks都是待传的-127~128整数列表，我们只需要在这里编写将其转换为比特流，然后信道编码、调制、通过信道、解调、信道译码、重新转为y_blocks、u_blocks和v_blocks即可实现传统通信系统</span></span><br><span class="line"><span class="comment">#############################</span></span><br><span class="line">        y = self.__Decode(y_blocks, self.__lt)  <span class="comment"># 224*224</span></span><br><span class="line">        u = self.__Decode(u_blocks, self.__ct)</span><br><span class="line">        v = self.__Decode(v_blocks, self.__ct)</span><br><span class="line">        r = (y + <span class="number">1.402</span> * (v - <span class="number">128</span>))</span><br><span class="line">        g = (y - <span class="number">0.34414</span> * (u - <span class="number">128</span>) - <span class="number">0.71414</span> * (v - <span class="number">128</span>))</span><br><span class="line">        b = (y + <span class="number">1.772</span> * (u - <span class="number">128</span>))</span><br><span class="line">        r = Image.fromarray(r).convert(<span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">        g = Image.fromarray(g).convert(<span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">        b = Image.fromarray(b).convert(<span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">        image = Image.merge(<span class="string">&quot;RGB&quot;</span>, (r, g, b))</span><br><span class="line">        image.save(<span class="string">&quot;./result.bmp&quot;</span>, <span class="string">&quot;bmp&quot;</span>)</span><br><span class="line">        image.show()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__VLI</span>(<span class="params">self, n</span>):</span><br><span class="line">        <span class="comment"># 获取整数n的可变字长整数编码</span></span><br><span class="line">        ts, tl = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            ts = <span class="built_in">bin</span>(n)[<span class="number">2</span>:]</span><br><span class="line">            tl = <span class="built_in">len</span>(ts)</span><br><span class="line">        <span class="keyword">elif</span> n &lt; <span class="number">0</span>:</span><br><span class="line">            tn = (-n) ^ <span class="number">0xFFFF</span></span><br><span class="line">            tl = <span class="built_in">len</span>(<span class="built_in">bin</span>(-n)[<span class="number">2</span>:])</span><br><span class="line">            ts = <span class="built_in">bin</span>(tn)[-tl:]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            tl = <span class="number">0</span></span><br><span class="line">            ts = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> (tl, ts)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__IVLI</span>(<span class="params">self, tl, ts</span>):</span><br><span class="line">        <span class="comment"># 获取可变字长整数编码对应的整数n</span></span><br><span class="line">        <span class="keyword">if</span> tl != <span class="number">0</span>:</span><br><span class="line">            n = <span class="built_in">int</span>(ts, <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> ts[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">                n = n ^ <span class="number">0xFFFF</span></span><br><span class="line">                n = <span class="built_in">int</span>(<span class="built_in">bin</span>(n)[-tl:], <span class="number">2</span>)</span><br><span class="line">                n = -n</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            n = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    kjpeg = KJPEG()</span><br><span class="line">    kjpeg.Compress(<span class="string">&quot;./source1_224.jpg&quot;</span>)</span><br><span class="line">    kjpeg.Decompress(<span class="string">&quot;./source1_224.gpj&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>​	上述算法仅仅展示了JPEG压缩和解压缩的过程，并且没有使用huffman编码，因为模拟无线环境传输时可以直接使用定长编码替代</p>
<p>​	通信系统在<code>Decompress</code>函数中实现</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://JrunDing.github.io">JrunDing</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://jrunding.github.io/2023/07/20/JPEG%E5%8E%8B%E7%BC%A9-%E8%A7%A3%E5%8E%8B%E7%BC%A9%E7%94%A8%E4%BA%8E%E6%97%A0%E7%BA%BF%E9%80%9A%E4%BF%A1/">http://jrunding.github.io/2023/07/20/JPEG%E5%8E%8B%E7%BC%A9-%E8%A7%A3%E5%8E%8B%E7%BC%A9%E7%94%A8%E4%BA%8E%E6%97%A0%E7%BA%BF%E9%80%9A%E4%BF%A1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://JrunDing.github.io" target="_blank">JrunDing</a>！</span></div></div><div class="tag_share"><div class="post_share"><div class="social-share" data-image="https://s1.ax1x.com/2023/03/03/ppkg98x.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E6%96%87%E4%BB%B6%E5%92%8C%E5%8E%8B%E7%BC%A9%E6%A0%87%E5%87%86"><span class="toc-number">1.</span> <span class="toc-text">图像文件和压缩标准</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JPEG"><span class="toc-number">2.</span> <span class="toc-text">JPEG</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JPEG%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E6%A0%BC%E5%BC%8F"><span class="toc-number">3.</span> <span class="toc-text">JPEG文件存储格式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JPEG%E7%94%A8%E4%BA%8E%E6%97%A0%E7%BA%BF%E5%9B%BE%E5%83%8F%E4%BC%A0%E8%BE%93"><span class="toc-number">4.</span> <span class="toc-text">JPEG用于无线图像传输</span></a></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('https://s1.ax1x.com/2023/03/03/ppkg98x.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By JrunDing</div><div class="footer_custom_text">Wish to feel nothing.</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'http://jrunding.github.io/2023/07/20/JPEG%E5%8E%8B%E7%BC%A9-%E8%A7%A3%E5%8E%8B%E7%BC%A9%E7%94%A8%E4%BA%8E%E6%97%A0%E7%BA%BF%E9%80%9A%E4%BF%A1/'
    this.page.identifier = '/2023/07/20/JPEG%E5%8E%8B%E7%BC%A9-%E8%A7%A3%E5%8E%8B%E7%BC%A9%E7%94%A8%E4%BA%8E%E6%97%A0%E7%BA%BF%E9%80%9A%E4%BF%A1/'
    this.page.title = 'JPEG压缩/解压缩用于无线通信'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://jrunding.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }

  document.getElementById('darkmode').addEventListener('click', () => {
    setTimeout(() => window.disqusReset(), 200)
  })
}

if ('Disqus' === 'Disqus' || !false) {
  if (false) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script><script>if (window.DISQUSWIDGETS === undefined) {
  var d = document, s = d.createElement('script');
  s.src = 'https://jrunding.disqus.com/count.js';
  s.id = 'dsq-count-scr';
  (d.head || d.body).appendChild(s);
} else {
  DISQUSWIDGETS.getCount({reset: true});
}</script></div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>