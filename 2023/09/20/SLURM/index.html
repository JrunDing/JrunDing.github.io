<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>SLURM | JrunDing</title><meta name="author" content="JrunDing"><meta name="copyright" content="JrunDing"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="最近要用到集群，了解到SLURM集群资源和作业管理软件，简单介绍，详细可参考下方链接  简介用途​	Slurm(Simple Linux Utility for Resource Management， http:&#x2F;&#x2F;slurm.schedmd.com&#x2F; )是开源的、具有容错性和高度可扩展的Linux集群超级计算系统资源管理和作业调度系统。超级计算系统可利用Slurm对资源和作业进行管理，以避免">
<meta property="og:type" content="article">
<meta property="og:title" content="SLURM">
<meta property="og:url" content="http://jrunding.github.io/2023/09/20/SLURM/index.html">
<meta property="og:site_name" content="JrunDing">
<meta property="og:description" content="最近要用到集群，了解到SLURM集群资源和作业管理软件，简单介绍，详细可参考下方链接  简介用途​	Slurm(Simple Linux Utility for Resource Management， http:&#x2F;&#x2F;slurm.schedmd.com&#x2F; )是开源的、具有容错性和高度可扩展的Linux集群超级计算系统资源管理和作业调度系统。超级计算系统可利用Slurm对资源和作业进行管理，以避免">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://z1.ax1x.com/2023/12/10/piRckct.jpg">
<meta property="article:published_time" content="2023-09-20T00:45:27.000Z">
<meta property="article:modified_time" content="2023-09-20T02:23:33.402Z">
<meta property="article:author" content="JrunDing">
<meta property="article:tag" content="Communication, Automation, ML, DL, NLP, CV, Movie, photography">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://z1.ax1x.com/2023/12/10/piRckct.jpg"><link rel="shortcut icon" href="https://z1.ax1x.com/2023/11/13/piJMDnH.jpg"><link rel="canonical" href="http://jrunding.github.io/2023/09/20/SLURM/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: JrunDing","link":"链接: ","source":"来源: JrunDing","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'SLURM',
  isPost: true,
  isHome: false,
  isHighlightShrink: undefined,
  isToc: true,
  postUpdate: '2023-09-20 10:23:33'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js/themes/blue/pace-theme-minimal.min.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://z1.ax1x.com/2023/11/13/piJMDnH.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">230</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/talk/"><span> Talk</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><span> Music</span></a></div><div class="menus_item"><a class="site-page" href="/movie/"><span> Movie</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://z1.ax1x.com/2023/12/10/piRckct.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="JrunDing"></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/talk/"><span> Talk</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><span> Music</span></a></div><div class="menus_item"><a class="site-page" href="/movie/"><span> Movie</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">SLURM</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-09-20T00:45:27.000Z" title="发表于 2023-09-20 08:45:27">2023-09-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-09-20T02:23:33.402Z" title="更新于 2023-09-20 10:23:33">2023-09-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Computer-Science/">Computer Science</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>19分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="SLURM"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><span class="disqus-comment-count"><a href="http://jrunding.github.io/2023/09/20/SLURM/#disqus_thread"><i class="fa-solid fa-spinner fa-spin"></i></a></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>最近要用到集群，了解到SLURM集群资源和作业管理软件，简单介绍，详细可参考下方链接</p>
</blockquote>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>​	Slurm(Simple Linux Utility for Resource Management， <a target="_blank" rel="noopener" href="http://slurm.schedmd.com/">http://slurm.schedmd.com/</a> )是开源的、具有容错性和高度可扩展的Linux集群超级计算系统资源管理和作业调度系统。超级计算系统可利用Slurm对资源和作业进行管理，以避免相互干扰，提高运行效率。所有需运行的作业，无论是用于程序调试还是业务计算，都可以通过交互式并行 <code>srun</code> 、批处理式 <code>sbatch</code> 或分配式 <code>salloc</code> 等命令提交，提交后可以利用相关命令查询作业状态等。</p>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>​	Slurm采用slurmctld服务（守护进程）作为中心管理器用于监测资源和作业，为了提高可用性，还可以配置另一个备份冗余管理器。各计算节点需启动slurmd守护进程，以便被用于作为远程shell使用：等待作业、执行作业、返回状态、再等待更多作业。slurmdbd(Slurm DataBase Daemon)数据库守护进程（非必需，建议采用，也可以记录到纯文本中等），可以将多个slurm管理的集群的记账信息记录在同一个数据库中。还可以启用slurmrestd(Slurm REST API Daemon)服务（非必需），该服务可以通过REST API与Slurm进行交互，所有功能都对应的API。用户工具包含 <code>srun</code> 运行作业、 <code>scancel</code> 终止排队中或运行中的作业、 <code>sinfo</code> 查看系统状态、 <code>squeue</code> 查看作业状态、 <code>sacct</code> 查看运行中或结束了的作业及作业步信息等命令。 <code>sview</code> 命令可以图形化显示系统和作业状态（可含有网络拓扑）。 <code>scontrol</code> 作为管理工具，可以监控、修改集群的配置和状态信息等。用于管理数据库的命令是 <code>sacctmgr</code> ，可认证集群、有效用户、有效记账账户等。</p>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ul>
<li>节点</li>
</ul>
<p>​		Hea Node：头节点、管理节点、控制节点，运行slurmctld管理服务的节点。</p>
<p>​		Compute Node：计算节点，运行作业计算任务的节点，需运行slurmd服务。</p>
<p>​		Login Node：用户登录节点，用于用户登录的节点。</p>
<p>​		SlurmDBD Node：SlurmDBD节点、SlurmDBD数据库节点，存储调度策略、记账和作业等信息的节点，需运行slurmdbd服务。</p>
<p>​		客户节点：含计算节点和用户登录节点。</p>
<ul>
<li>用户</li>
</ul>
<p>​		account：账户，一个账户可以含有多个用户。</p>
<p>​		user：用户，多个用户可以共享一个账户。</p>
<p>​		bank account：银行账户，对应机时费等。</p>
<ul>
<li>资源</li>
</ul>
<p>​		GRES：Generic Resource，通用资源。</p>
<p>​		TRES：Trackable RESources，可追踪资源。</p>
<p>​		QOS：Quality of Service，服务质量，作业优先级。</p>
<p>​		association：关联。可利用其实现，如用户的关联不在数据库中，这将阻止用户运行作业。该选项可以阻止用户访问无效账户。</p>
<p>​		Partition：队列、分区。用于对计算节点、作业并行规模、作业时长、用户等进行分组管理，以合理分配资源。</p>
<h1 id="规划准备"><a href="#规划准备" class="headerlink" title="规划准备"></a>规划准备</h1><p>​	集群名：MyCluster</p>
<p>​	<strong>管理节点admin：</strong></p>
<ul>
<li><p>内网IP：191.168.1.254</p>
</li>
<li><p><strong>&#x2F;opt&#x2F;</strong> 目录：通过NFS网络共享给其它节点使用</p>
</li>
<li><p>配置文件： <strong>&#x2F;etc&#x2F;slurm&#x2F;</strong> 目录下的 <strong>cgroup.conf</strong> 、 <strong>slurm.conf</strong> 、 <strong>slurmdbd.conf</strong> 等文件</p>
</li>
<li><p>需要启动（按顺序）的守护进程服务：</p>
<blockquote>
<ol>
<li>通信认证：munge</li>
<li>系统数据库：mariadb（也可采用文本保存，更简单，本文不涉及）</li>
<li>Slurm数据库：slurmdbd</li>
<li>主控管理器：slurmctld</li>
</ol>
</blockquote>
</li>
</ul>
<p>​	<strong>数据库节点（运行slurmdbd服务）admin：</strong></p>
<ul>
<li>可与管理节点共用，本文档与管理节点共用</li>
</ul>
<p>​	<strong>用户登录节点login：</strong></p>
<ul>
<li>内网IP：191.168.1.250</li>
<li><strong>&#x2F;opt&#x2F;</strong> 目录：通过NFS服务共享管理节点上的 <strong>&#x2F;opt&#x2F;</strong> 目录</li>
</ul>
<p>​	<strong>计算节点node[1-10]：</strong></p>
<ul>
<li><p>内网IP：191.168.1.[1-10]</p>
</li>
<li><p><strong>&#x2F;opt&#x2F;</strong> 目录：通过NFS服务共享管理节点上的 <strong>&#x2F;opt&#x2F;</strong> 目录</p>
</li>
<li><ul>
<li><p>需要启动（按顺序）的服务：</p>
<p>通信认证：mungeSlurm数据库：slurmdbd</p>
</li>
</ul>
</li>
</ul>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="编写slurm脚本"><a href="#编写slurm脚本" class="headerlink" title="编写slurm脚本"></a>编写slurm脚本</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH -J <span class="built_in">test</span> <span class="comment"># 作业名是 test</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH -p defq <span class="comment"># 提交到 默认的defq 队列</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH -N 2 <span class="comment"># 使用2个节点</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH --ntasks-per-node=6 <span class="comment"># 每个节点开启6个进程</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH --cpus-per-task=1 <span class="comment"># 每个进程占用一个 cpu 核心</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH -t 50:00 <span class="comment"># 任务最大运行时间是 50 分钟</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH --gres=gpu:1 <span class="comment"># 如果是gpu任务需要在此行定义gpu数量,此处为1</span></span></span><br><span class="line">module load openmpi/gcc/64/1.10.7</span><br><span class="line">mpirun ./a.out # 执行我编译的的 ./a.out 程序</span><br></pre></td></tr></table></figure>

<p>​	脚本的第一行指定了这个脚本的解释器为 bash。每次编写脚本 都必须写上这一行。之后有 # 开头的若干行表示 SLURM 作业的设置区域，它 告诉工作站运行任务的详细设定：它被提交到defq 队列当中，申请 2 个节点的 总共12 个 核心，每个节点调用1个gpu，限制任务最大运行时间是50分钟， 它的主体内容就是在当前目录执行我编译好的程序 a.out。</p>
<p>​	上面的例子是最简单的批处理任务，较为完整的设置后面会介绍。另外用户也可提交交互式任务来完成计算。</p>
<h2 id="提交任务"><a href="#提交任务" class="headerlink" title="提交任务"></a>提交任务</h2><p>​	在提交任务之前，先使用 sinfo 查看可用资源情况。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sinfo</span></span><br><span class="line">PARTITION AVAIL TIMELIMIT NODES STATE NODELIST</span><br><span class="line">     defq*   up  infinite    21  idle node[001-021]</span><br><span class="line">     gpu     up  infinite     1  idle node021</span><br></pre></td></tr></table></figure>

<p>​	我们看到目前的 defq 分区处于空闲状态(idle)，任务可以提交。准备好 SLURM 脚本之后，使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sbatch job.sh</span><br></pre></td></tr></table></figure>

<p>​	就可以将刚才的任务提交上去，这里 sbatch 是提交 SLURM 脚本的命令。 如果工作站有空闲资源，那么我的程序将会被放在某2个节点的12个核心上运行。我只需要等待我的程序完成即可。</p>
<p>​	提交完成后，会输出以下提示<code>Submitted batch job 416</code></p>
<p>​	数字编号即为当前任务编号，这个ID非常重要，查询 诊断 删除都需要此ID号</p>
<p>​	使用 sbatch 时如果指定的参数不当会导致提交失败。使用 squeue 命令可以查询 目前正在运行的任务，通过查询的结果来判断提交是否成功。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[test@admin ~]$ sbatch sl.sh</span><br><span class="line">Submitted batch job 416</span><br><span class="line">[test@admin ~]$ squeue</span><br><span class="line">             JOBID PARTITION NAME USER ST TIME NODES NODELIST(REASON)</span><br><span class="line">               416      defq arraytest R  4:17     2     node[01-02]</span><br></pre></td></tr></table></figure>

<p>​	在以上输出中，sbatch 返回信息是Submitted batch job 416 这表示我的 任务已经成功提交任务(作业&#x2F;jobid)号是 416。而 squeue 显示我提交的任务的具体信息，在这里 看到我的任务被放到 defq 队列上运行，占用 2 个节点 node01,node02，状态(ST)是运行 状态(R)，并且已经运行了 4分17秒。</p>
<h2 id="输出文件"><a href="#输出文件" class="headerlink" title="输出文件"></a>输出文件</h2><p>​	当我的程序完成后，我应该到我指定的文件中去寻找程序的输出。 系统默认会将标准输出文件和标准错误文件生成到调用 sbatch 的目录下(提交当前任务的目录)。默认的 文件名是 slurm-<JOBID>.out ，其中 JOBID 是作业号。如果在 SLURM 脚本中使用 了 -o 选项，则这些文件会被生成到用户所指定的目录下。</p>
<p>​	这里讲的输出文件只包含程序运行时打印在屏幕上的内容，即标准输出流和标准错误流。 程序的其他输出（例如 MATLAB 存储的 .mat 文件，python 输出的图像）则需要用户 手动将这些数据存下来。若不手动指定，这些数据将会丢失。</p>
<p>​	总结起来，在集群上进行运算的步骤如下：</p>
<ul>
<li>登录主节点，准备程序和数据。</li>
<li>编写 SLURM 脚本，设置作业属性（例如占用的资源，最长运行时间）。</li>
<li>检查可用资源，提交作业脚本，检查任务状态（使用 squeue 和 sinfo ）。</li>
<li>等待运行结束，验收结果。</li>
</ul>
<h2 id="在slurm脚本中使用module"><a href="#在slurm脚本中使用module" class="headerlink" title="在slurm脚本中使用module"></a>在slurm脚本中使用module</h2><p>​	module 命令仅作用在当前节点上，如果使用 SLURM 脚本提交任务，那么实际运行任务的 节点和当前节点是不同的，因此方便的做法是将 module 命令一并写在 SLURM 脚本中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH -J <span class="built_in">test</span> <span class="comment"># 作业名是 test</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH -p defq <span class="comment"># 提交到 默认的defq 队列</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH -N 2 <span class="comment"># 使用2个节点</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH --ntasks-per-node=6 <span class="comment"># 每个节点开启6个进程</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH --cpus-per-task=1 <span class="comment"># 每个进程占用一个 cpu 核心</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH -t 50:00 <span class="comment"># 任务最大运行时间是 50 分钟</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH --gres=gpu:1 <span class="comment"># 如果是gpu任务需要在此行定义gpu数量,此处为1</span></span></span><br><span class="line">module load openmpi/gcc/64/1.10.7</span><br><span class="line">mpirun ./a.out # 执行我编译的的 ./a.out 程序</span><br></pre></td></tr></table></figure>

<h2 id="定制你自己的默认载入-module"><a href="#定制你自己的默认载入-module" class="headerlink" title="定制你自己的默认载入 module"></a>定制你自己的默认载入 module</h2><p>​	当你登录系统时，系统会默认载入一些 module。如果这些 module 不是你需要的，或者你 需要载入更多的 module，那么请直接在个人 HOME 目录下的 .bashrc 文件的 最后添加</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">module load &lt;module name&gt;</span><br></pre></td></tr></table></figure>

<p>​	即可。每个 module 的添加单独占一行。这样每次你登录系统之后系统就会自动加载你指定的 module，也非常方便管理</p>
<p>​	更改 .bash_profile 文件的同时，在你运行 SLURM 任务时也会自动载入你添加的这些 module， 因此无需在 SLURM 脚本中再次添加 module 命令！</p>
<h1 id="提交交互式任务"><a href="#提交交互式任务" class="headerlink" title="提交交互式任务"></a>提交交互式任务</h1><p>​	交互式任务是一种特殊的队列任务，在该模式下，用户可以直接登录到计算节点，此后 所有的操作都在这个节点上进行。这个功能主要是方便用户在服务器上调试程序， 以便能够实时看到程序的输出。</p>
<h2 id="直接申请资源方式"><a href="#直接申请资源方式" class="headerlink" title="直接申请资源方式"></a>直接申请资源方式</h2><p>​	我们需要使用 salloc 命令来分配交互式任务所需的资源，它的语法为</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">salloc [申请资源]</span></span><br></pre></td></tr></table></figure>

<p>​	其中，用户需要以选项的方式指定申请的资源，这些选项与 SLURM 脚本中的选项基本 相同。常用选项为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-N &lt;节点数量&gt;</span><br><span class="line">-n &lt;总进程数&gt;</span><br><span class="line">--ntasks-per-node=&lt;每节点的进程数&gt;</span><br><span class="line">--cpus-per-task=&lt;每进程的CPU核心数&gt;</span><br><span class="line">--gres=gpu:&lt;每节点的GPU卡数&gt;</span><br><span class="line">-t &lt;最长运行时间&gt;</span><br><span class="line">-p &lt;指定使用的队列&gt;</span><br><span class="line">--qos=&lt;指定使用的 QoS&gt;</span><br></pre></td></tr></table></figure>

<p>​	例如，可以使用如下方式申请资源：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">salloc -N 1 --cpus-per-task=4 -t 5:00</span></span><br></pre></td></tr></table></figure>

<p>​	执行成功后，SLURM 会给你一个新的 Shell，注意此时用户所在节点仍为主节点，但是如使用mpirun运行计算任务，会自动提交到申请的节点上运行，或者ssh到申请的计算节点上运行</p>
<p>​	在策略配置略微严格的集群中，如计算节点没有当前用户已提交的的任务，是被禁止ssh过去的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[test@admin ~]$ salloc -N 1 --cpus-per-task=4 -t 5:00</span><br><span class="line">salloc: Granted job allocation 419</span><br><span class="line">[test@admin ~]$ squeue</span><br><span class="line">JOBID PARTITION NAME USER ST TIME NODES</span><br><span class="line">NODELIST(REASON)</span><br><span class="line">419 defq bash test1 R 0:06 1 node021</span><br><span class="line">[test@admin ~]$ ssh node021 # 这就是 salloc 分配的节点</span><br><span class="line">Last login: Thu Jan 23 01:45:41 2020 from admin.cm.cluster</span><br></pre></td></tr></table></figure>

<p>​	如上所示，执行 salloc 后，SLURM 会自动分配作业号并可以通过squeue 查看哪个节点是可用的。成功 获取资源后，你会进入到一个新的环境，此时用户可以直接切换到目标节点 comput1 执行运算任务。</p>
<p>​	交互式计算使用完毕后，先使用 exit 退出节点，再执行 exit 退出 SLURM 分配 的 Shell，可结束这次交互式任务。SLURM 会提示你交互式任务的资源已经被释放。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[test@node021 ~]$ exit # 这一步是退出 node021</span><br><span class="line">logout</span><br><span class="line">Connection to node021 closed.</span><br><span class="line">[test1@bsbii ~]$ exit # 这一步是退出 salloc 分配的 shell</span><br><span class="line">exit</span><br><span class="line">salloc: Relinquishing job allocation 419 # 退出的同时也释放了资源</span><br></pre></td></tr></table></figure>

<p>​	用户会重新回到 管理节点原始命令行下进行操作。</p>
<h2 id="申请资源并自动分类计算节点终端方式"><a href="#申请资源并自动分类计算节点终端方式" class="headerlink" title="申请资源并自动分类计算节点终端方式"></a>申请资源并自动分类计算节点终端方式</h2><p>​	部分管理较为严格的集群中，管理员会禁止用户通过ssh登录到计算节点，如遇到特殊情况必须要在计算节点的终端运行，可以通过srun 来申请资源并自动开启一个计算节点终端</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[test@admin ~]$ srun -N 1 --cpus-per-task=4 -t 5:00 --gres=gpu:1 --pty bash</span><br><span class="line">[test@node021 ~]$</span><br><span class="line">[test@node021 ~]$ nvidia-smi</span><br><span class="line">Sat Feb 1 12:17:12 2020</span><br><span class="line">+-----------------------------------------------------------------------------+</span><br><span class="line">| NVIDIA-SMI 418.87.01 Driver Version: 418.87.01 CUDA Version: 10.1 |</span><br><span class="line">|-------------------------------+----------------------+----------------------+</span><br><span class="line">| GPU Name Persistence-M| Bus-Id Disp.A | Volatile Uncorr. ECC |</span><br><span class="line">| Fan Temp Perf Pwr:Usage/Cap| Memory-Usage | GPU-Util Compute M. |</span><br><span class="line">|===============================+======================+======================|</span><br><span class="line">| 0 Tesla V100-PCIE... On | 00000000:18:00.0 Off | 0 |</span><br><span class="line">| N/A 31C P0 25W / 250W | 0MiB / 32480MiB | 0% Default |</span><br><span class="line">+-------------------------------+----------------------+----------------------+</span><br><span class="line">+-----------------------------------------------------------------------------+</span><br><span class="line">| Processes: GPU Memory |</span><br><span class="line">| GPU PID Type Process name Usage |</span><br><span class="line">|=============================================================================|</span><br><span class="line">| No running processes found |</span><br><span class="line">+-----------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure>

<p>​	通过以上方式，申请了相关资源并且开启了一个计算节点终端</p>
<p>​	注意事项</p>
<ul>
<li>如果 salloc 命令无响应，可能是目前所剩计算资源小于申请的资源，需要检查你的填写参数或等计算任务少的时候再试。</li>
<li><strong>原则上管理节点只能进行登录，修改文件，编译程序等任务。严禁在管理节点上直接运行需要大量运算的程序。管理员有权在不经过用户同意的情况下强行中止长时间运行在管理节点上的大型程序（占用较多 CPU 或者内存的程序）。</strong></li>
</ul>
<p>​	建议</p>
<ul>
<li>salloc 建议用作多机并行的任务，这样可以很方便快速地开始计算</li>
<li>srun 开启计算节点终端的方式，建议用作单机测试和计算的任务，比如<br>1.申请资源并分配一个计算节点终端后，打开软件的图形界面并调用本地资源<br>2.申请资源并分配一个计算节点终端后，开启一个jupyter的后台任务<br>3.申请资源并分配一个计算节点终端后，直接调用本地资源计算</li>
</ul>
<h1 id="提交批处理任务"><a href="#提交批处理任务" class="headerlink" title="提交批处理任务"></a>提交批处理任务</h1><p>​	在工作站提交批处理任务需要编写 SLURM 脚本，以便明确申请的资源以及所要运行的程序。</p>
<h2 id="查看可用资源"><a href="#查看可用资源" class="headerlink" title="查看可用资源"></a>查看可用资源</h2><p>​	在提交任务之前，务必检查一下各个节点的状态，例如资源是否充足，当前有多少正在执 行的任务等。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[cmsupport@admin ~]$ sinfo</span><br><span class="line">PARTITION AVAIL TIMELIMIT NODES STATE NODELIST</span><br><span class="line">defq*        up infinite      1   mix  node021</span><br><span class="line">defq*        up infinite     20  idle node[001-020]</span><br><span class="line"> gpu         up infinite      1  mix   node021</span><br></pre></td></tr></table></figure>

<p>​	如上所示，使用 sinfo 可粗略查看所有分区的节点信息，<strong>注意 ‘‘STATE’’ 一栏的输出 若为 ‘‘idle’’ 表示该节点处于闲置状态，若为 ‘‘alloc’’ 表示该节点已经没有多余的 资源了，若为 ‘‘mix’’ 表示该节点有人在占用，但是仍然有剩余资源。</strong></p>
<p>​	对于 gpu 队列的节点 node021，如果显示 ‘‘mix’’ 表示部分资源被占用，可能出现 GPU 卡都被占用但是有空闲 CPU 核心的情况。此时我们需要这个节点更详细的信息。可以使用 scontrol show node &lt;节点名&gt; 命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[cmsupport@admin ~]$ scontrol show node node021</span><br><span class="line">NodeName=node021 Arch=x86_64 CoresPerSocket=16</span><br><span class="line">CPUAlloc=2 CPUTot=64 CPULoad=0.06</span><br><span class="line">AvailableFeatures=(null)</span><br><span class="line">ActiveFeatures=(null)</span><br><span class="line">Gres=gpu:2</span><br><span class="line">NodeAddr=node021 NodeHostName=node021 Version=18.08</span><br><span class="line">OS=Linux 3.10.0-957.1.3.el7.x86_64 #1 SMP Thu Nov 29 14:49:43 UTC 2018</span><br><span class="line">RealMemory=192030 AllocMem=0 FreeMem=183286 Sockets=2 Boards=1</span><br><span class="line">State=MIXED ThreadsPerCore=2 TmpDisk=212445 Weight=1 Owner=N/A MCS_label=N/A</span><br><span class="line">Partitions=defq,gpu</span><br><span class="line">BootTime=2019-12-12T18:43:16 SlurmdStartTime=2020-02-13T00:15:07</span><br><span class="line">CfgTRES=cpu=64,mem=192030M,billing=64,gres/gpu=2</span><br><span class="line">AllocTRES=cpu=2,gres/gpu=2</span><br><span class="line">CapWatts=n/a</span><br><span class="line">CurrentWatts=0 LowestJoules=0 ConsumedJoules=0</span><br><span class="line">ExtSensorsJoules=n/s ExtSensorsWatts=0 ExtSensorsTemp=n/s</span><br></pre></td></tr></table></figure>

<p>​	如上所示， sinfo 显示 gpu 队列的 node021 状态是 ‘‘mix’’，但是使用 scontrol 命令查看发现已经占用的资源为 AllocTRES&#x3D;cpu&#x3D;2,gres&#x2F;gpu&#x3D;2，即占用 了 2个 CPU 核心和 2 块 GPU 卡。GPU 卡已经全部占用，这个节点将 无法运行需要 GPU 的任务。但仍然可运行纯 CPU 任务。</p>
<p>​	此外，管理员还提供了3个有用的命令 snode pestat 用于查看各个节点的状态 与集群所有任务的运行情况。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[cmsupport@admin ~]$ snode</span><br><span class="line">JOBID USER NAME CPUS NODES TRES_PER_NODE PARTITION NODELIST</span><br><span class="line">459 cmsupport bash 2 1 gpu:2 defq</span><br><span class="line">node021</span><br></pre></td></tr></table></figure>

<h2 id="编写slurm脚本-1"><a href="#编写slurm脚本-1" class="headerlink" title="编写slurm脚本"></a>编写slurm脚本</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH -J <span class="built_in">test</span> <span class="comment"># 作业名是 test</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH -p defq <span class="comment"># 提交到 defq 队列</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH -N 2 <span class="comment"># 使用2个节点</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH --ntasks-per-node=6 <span class="comment"># 每个节点开启6个进程</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH --cpus-per-task=1 <span class="comment"># 每个进程占用一个 cpu 核心</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH -t 50:00 <span class="comment"># 任务最大运行时间是 50 分钟 (非必需项)</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH --gres=gpu:1 <span class="comment"># 如果是gpu任务需要在此行定义gpu数量,此处为1</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH -w node01 <span class="comment"># 指定某个节点 (非必需项)</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加载运行环境</span></span><br><span class="line">module load openmpi/gcc/64/1.10.7</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输入要执行的命令</span></span><br><span class="line">mpirun ./a.out # 执行我编译的的 ./a.out 程序</span><br></pre></td></tr></table></figure>

<p>​	其中，第一行是固定的，表示使用 &#x2F;bin&#x2F;bash 来执行脚本。其余的说明如下</p>
<ul>
<li>申请时请写对队列 (Partition) ，由于不同的队列硬件配置不同。</li>
<li>申请的资源不要超过当前队列的最大值，建议使用 scontrol 命令查看队列的剩余资源数。确定申请 CPU 核心数量之前，请确认你的程序是否真的需要这些计算资源。如果 程序的并行程度不高，申请过多的 CPU 核心数会造成资源的浪费（多数 CPU 占用率会较 低），并且会影响他人使用。</li>
<li>实际在每个节点上分配的 CPU 数量由 –ntasks-per-node 和 –cpus-per-task 参数共同决定。默认情况下二者都是 1。一般来讲，多进程的程序需要更改 –ntasks-per-node ，多线程的程序需要更改 –cpus-per-task 。各位用户请根据 自己需求进行设置。</li>
<li>任务最长时间的设置格式是 DD-HH:MM:SS ，例如一天又 15 小时写作 1-15:00:00 。 如果高位为0 可省略。如果不写任务最长时间，则任务的最长时间默认为对应队列 (Partition) 的默认时间。</li>
</ul>
<p>​	以上的所有 #SBATCH 属性均可以不设置，当缺少某属性时，系统将使用默认值。</p>
<p>​	请在使用时估计自己任务的开销，适量申请计算资源，避免造成资源的浪费。</p>
<h2 id="常见的计算软件-x2F-软件库的启动命令"><a href="#常见的计算软件-x2F-软件库的启动命令" class="headerlink" title="常见的计算软件&#x2F;软件库的启动命令"></a>常见的计算软件&#x2F;软件库的启动命令</h2><p>​	以下列出集群中常见的软件启动命令，可以作为手动编写 SLURM 脚本的参考，也可以 作为交互式计算的使用参考。</p>
<p>​	以命令行模式运行 MATLAB</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">matlab -nodesktop -nosplash -nodisplay</span></span><br></pre></td></tr></table></figure>

<p>​	使用 MATLAB 运行 m 脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">matlab -nodesktop -nosplash -nodisplay -r <span class="string">&quot;MATLAB 脚本名，不带 m 后缀&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>​	注意：MATLAB 脚本不能像其他语言（如 python，bash）等使用 shebang 来指定解释器， 因此执行一个 M 文件需要使用 MATLAB 内置命令。-r 参数的含义其实并不是“执行 一个脚本”，而是因为在MATLAB 的命令行中，输入命令可以等效于执行同名的脚本， 因此才使用这种方式。</p>
<p>​	使用 R 运行 R 脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">Rscript &lt;脚本名&gt;</span></span><br></pre></td></tr></table></figure>

<p>​	使用 python 运行 py 脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python &lt;脚本名&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="提交任务-1"><a href="#提交任务-1" class="headerlink" title="提交任务"></a>提交任务</h2><p>​	将 SLURM 脚本编写完毕并上传工作站后（或直接在工作站编辑），进入 SLURM 脚本的 目录，使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sbatch &lt;SLURM 脚本文件名&gt;</span></span><br></pre></td></tr></table></figure>

<p>​	即可提交任务</p>
<p>​	注意，如果参数设置不当 sbatch 命令会提交失败，此时需要检查你的参数并修改成正确的版本。用户需要使用 squeue 检查作业运行情况，若作业是因为参数不当而没有 运行，则需要修改 SLURM 脚本。</p>
<p>​	例如，执行 sbatch 后发现如下内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[cmsupport@admin playground]$ sbatch run.slurm</span><br><span class="line">sbatch: error: Batch job submission failed: Requested node configuration is not</span><br><span class="line">available</span><br></pre></td></tr></table></figure>

<p>​	说明指定的队列内没有所需的资源</p>
<p>​	有时 sbatch 命令会显示正常提交，但是任务始终无法运行，此时需要使用 squeue 查看任务排队的详细情况。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[cmsupport@admin playground]$ sbatch run.slurm</span><br><span class="line">Submitted batch job 55</span><br><span class="line">[cmsupport@admin playground]$ squeue</span><br><span class="line">JOBID PARTITION NAME USER ST TIME NODES NODELIST(REASON)</span><br><span class="line"> 55      cpu    test liuhy PD 0:00   1   (PartitionTimeLimit)</span><br></pre></td></tr></table></figure>

<p>​	此时 55 号作业的状态为 PD(Pending)，即“被挂起”，最后一列显示了原因是 PartitionTimeLimit，即申请的运行时间已经超过了该队列允许运行的最大时间，任务 永远不会运行。此时需要先使用 scancel 命令（详见下面的说明）取消任务，然后 修改 SLURM 脚本使得参数正确。</p>
<h2 id="查看任务状态"><a href="#查看任务状态" class="headerlink" title="查看任务状态"></a>查看任务状态</h2><p>​	作业提交完毕后，可使用 squeue 命令查看任务状态。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[cmsupport@admin playground]$ squeue</span><br><span class="line">JOBID PARTITION NAME USER ST TIME NODES NODELIST(REASON)</span><br><span class="line">55     cpu      test liuhy PD 0:00  1  (PartitionTimeLimit)</span><br><span class="line">54     cpu      test liuhy R  0:15  1   comput1</span><br></pre></td></tr></table></figure>

<p>​	如上所示，可显示目前任务号，所在队列，任务状态，已经运行时间，以及运行的节点。 如果任务处于挂起(PD)状态，则显示任务被挂起的原因。用户可以根据这个原因来判断 自己的作业脚本是否写对了。</p>
<p>​	除此之外，使用 squeue 配合不同参数可以过滤显示的内容，以便能看到你感兴趣的 结果。某些参数可以相互组合。</p>
<ul>
<li>squeue -l : 以长列表显示更多信息。</li>
<li>squeue -u username : 仅显示属于用户 username 的任务。</li>
<li>squeue -t state : 仅显示处于 state 状态的任务。<br>删除任务</li>
<li>scancel jobid : 删除 jobid 的作业。</li>
<li>scancel -u username : 删除 username 的全部作业。</li>
<li>scancel -s state : 删除处于 state 状态的作业。</li>
</ul>
<p>​	注意：用户只能删除自己的作业，不能删除别人的作业。</p>
<h1 id="集群计算常用范例"><a href="#集群计算常用范例" class="headerlink" title="集群计算常用范例"></a>集群计算常用范例</h1><p>​	我是一个GPU用户,如何使用集群的GPU资源来进行深度学习计算</p>
<p>​	这部分需要注意的是,集群内会装有不同版本的cuda,tensorflow等库和计算软件,请load对应的模块进行计算</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH -J <span class="built_in">test</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH -p defq</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH -N 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH --ntasks-per-node=1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH --cpus-per-task=6</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">SBATCH --gres=gpu:1</span></span><br><span class="line">module load tensorflow-py36-cuda10.1-gcc/1.14.0</span><br><span class="line">module load openmpi/cuda/64/3.1.4</span><br><span class="line">cd tensorflow_test</span><br><span class="line">python tf_cnn_benchmarks.py --num_gpus=1 --batch_size=32 --model=resnet50 -</span><br><span class="line">-variable_update=parameter_serve</span><br></pre></td></tr></table></figure>

<h1 id="常用命令和参数速查"><a href="#常用命令和参数速查" class="headerlink" title="常用命令和参数速查"></a>常用命令和参数速查</h1><p>​	调度器部分</p>
<p>​	最常用的 SLURM 命令：<br>​	sacct： 查看历史任务信息<br>​	salloc： 分配资源<br>​	sbatch： 提交批处理任务<br>​	scancel： 取消任务<br>​	scontrol： 系统控制<br>​	sinfo： 查看节点与队列状态<br>​	squeue： 查看任务状态<br>​	srun： 执行任务</p>
<p>​	slurm 内部环境变量<br>​	SLURM_NPROCS 任务要加载的总进程数<br>​	SLURM_TASKS_PER_NODE 每节点要加载的进程数<br>​	SLURM_JOB_ID 任务的 JobID<br>​	SLURM_SUBMIT_DIR 提交任务时的工作目录<br>​	SLURM_JOB_NODELIST 任务分配的节点列表<br>​	SLURM_JOB_CPUS_PER_NODE 每个节点上分配给任务的总 CPU核心数<br>​	SLURM_JOB_NUM_NODES 作业分配的节点数</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://JrunDing.github.io">JrunDing</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://jrunding.github.io/2023/09/20/SLURM/">http://jrunding.github.io/2023/09/20/SLURM/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://JrunDing.github.io" target="_blank">JrunDing</a>！</span></div></div><div class="tag_share"><div class="post_share"><div class="social-share" data-image="https://z1.ax1x.com/2023/12/10/piRckct.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E9%80%94"><span class="toc-number">1.1.</span> <span class="toc-text">用途</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text">架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AF%E8%AF%AD"><span class="toc-number">1.3.</span> <span class="toc-text">术语</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A7%84%E5%88%92%E5%87%86%E5%A4%87"><span class="toc-number">2.</span> <span class="toc-text">规划准备</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E5%86%99slurm%E8%84%9A%E6%9C%AC"><span class="toc-number">3.1.</span> <span class="toc-text">编写slurm脚本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4%E4%BB%BB%E5%8A%A1"><span class="toc-number">3.2.</span> <span class="toc-text">提交任务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%96%87%E4%BB%B6"><span class="toc-number">3.3.</span> <span class="toc-text">输出文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8slurm%E8%84%9A%E6%9C%AC%E4%B8%AD%E4%BD%BF%E7%94%A8module"><span class="toc-number">3.4.</span> <span class="toc-text">在slurm脚本中使用module</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E5%88%B6%E4%BD%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E9%BB%98%E8%AE%A4%E8%BD%BD%E5%85%A5-module"><span class="toc-number">3.5.</span> <span class="toc-text">定制你自己的默认载入 module</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4%E4%BA%A4%E4%BA%92%E5%BC%8F%E4%BB%BB%E5%8A%A1"><span class="toc-number">4.</span> <span class="toc-text">提交交互式任务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E7%94%B3%E8%AF%B7%E8%B5%84%E6%BA%90%E6%96%B9%E5%BC%8F"><span class="toc-number">4.1.</span> <span class="toc-text">直接申请资源方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%B3%E8%AF%B7%E8%B5%84%E6%BA%90%E5%B9%B6%E8%87%AA%E5%8A%A8%E5%88%86%E7%B1%BB%E8%AE%A1%E7%AE%97%E8%8A%82%E7%82%B9%E7%BB%88%E7%AB%AF%E6%96%B9%E5%BC%8F"><span class="toc-number">4.2.</span> <span class="toc-text">申请资源并自动分类计算节点终端方式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4%E6%89%B9%E5%A4%84%E7%90%86%E4%BB%BB%E5%8A%A1"><span class="toc-number">5.</span> <span class="toc-text">提交批处理任务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%8F%AF%E7%94%A8%E8%B5%84%E6%BA%90"><span class="toc-number">5.1.</span> <span class="toc-text">查看可用资源</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E5%86%99slurm%E8%84%9A%E6%9C%AC-1"><span class="toc-number">5.2.</span> <span class="toc-text">编写slurm脚本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E8%AE%A1%E7%AE%97%E8%BD%AF%E4%BB%B6-x2F-%E8%BD%AF%E4%BB%B6%E5%BA%93%E7%9A%84%E5%90%AF%E5%8A%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">5.3.</span> <span class="toc-text">常见的计算软件&#x2F;软件库的启动命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4%E4%BB%BB%E5%8A%A1-1"><span class="toc-number">5.4.</span> <span class="toc-text">提交任务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E4%BB%BB%E5%8A%A1%E7%8A%B6%E6%80%81"><span class="toc-number">5.5.</span> <span class="toc-text">查看任务状态</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E8%AE%A1%E7%AE%97%E5%B8%B8%E7%94%A8%E8%8C%83%E4%BE%8B"><span class="toc-number">6.</span> <span class="toc-text">集群计算常用范例</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%92%8C%E5%8F%82%E6%95%B0%E9%80%9F%E6%9F%A5"><span class="toc-number">7.</span> <span class="toc-text">常用命令和参数速查</span></a></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('https://z1.ax1x.com/2023/12/10/piRckct.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By JrunDing</div><div class="footer_custom_text">Wish to feel nothing.</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'http://jrunding.github.io/2023/09/20/SLURM/'
    this.page.identifier = '/2023/09/20/SLURM/'
    this.page.title = 'SLURM'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://jrunding.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }

  document.getElementById('darkmode').addEventListener('click', () => {
    setTimeout(() => window.disqusReset(), 200)
  })
}

if ('Disqus' === 'Disqus' || !false) {
  if (false) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script><script>if (window.DISQUSWIDGETS === undefined) {
  var d = document, s = d.createElement('script');
  s.src = 'https://jrunding.disqus.com/count.js';
  s.id = 'dsq-count-scr';
  (d.head || d.body).appendChild(s);
} else {
  DISQUSWIDGETS.getCount({reset: true});
}</script></div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>